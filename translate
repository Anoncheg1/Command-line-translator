#!/bin/bash
# This tool for access translate.google.com from terminal and to have English dictionary.
# main mirror https://github.com/Anoncheg1/Command-line-translator
# mirror http://pastebin.com/kPTYjY6W
# write to me there: http://www.unix.com/shell-programming-scripting/196823-completed-command-line-google-translation-tool.html
# requirements: curl, Mozilla js shell (spidermonkey), forvo.com account
#features:
#- translated text, fixed text with highlight, language detection, dictionary
#- for english:  phrases, ideom, transcription, audio pronunciation
#- cache for words
#- saving words to file for learning

help='translate [-s] <text>
if text is english, target language is ENGLISH_TARGET_LANG
otherwise, "target" language is english
-s, --sound Enable sound for one word
You can set language with environment varibles by command:
export TLSOURCE=en TLTARGET=ru; will set language source English and target Russian language
'

# adjust to taste
ENGLISH_TARGET_LANG=ru		#target language for english request
target=en 			#target for all languages except english
flogin=121212 			#forvo.com login and pass REQUIRED!
fpass=121212
words_buffer=4000	#4000 files max. there is removeing all files older than 20 days.
#httpproxy="127.0.0.1:4444"		#proxy for long strings
#httpsproxy="--socks5 127.0.0.1:9050"	#socks5
timeout=6
[ $(whoami) == "root" ] && PR_DIR="/root/.translate/" || PR_DIR="/home/$USER/.translate"
useragent="Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.34 (KHTML, like Gecko) QupZilla/1.3.1 Safari/534.34"
#
declare -A ln_arr
ln_arr["af"]="Afrikaans"
ln_arr["sq"]="Albanian"
ln_arr["am"]="Amharic"
ln_arr["ar"]="Arabic"
ln_arr["hy"]="Armenian"
ln_arr["az"]="Azerbaijani"
ln_arr["eu"]="Basque"
ln_arr["be"]="Belarusian"
ln_arr["bn"]="Bengali"
ln_arr["bg"]="Bulgarian"
ln_arr["ca"]="Catalan"
ln_arr["zh-CN"]="Chinese (Simplified)"
ln_arr["hr"]="Croatian"
ln_arr["cs"]="Czech"
ln_arr["da"]="Danish"
ln_arr["nl"]="Dutch"
ln_arr["en"]="English"
ln_arr["eo"]="Esperanto"
ln_arr["et"]="Estonian"
ln_arr["fo"]="Faroese"
ln_arr["tl"]="Filipino"
ln_arr["fi"]="Finnish"
ln_arr["fr"]="French"
ln_arr["gl"]="Galician"
ln_arr["ka"]="Georgian"
ln_arr["de"]="German"
ln_arr["el"]="Greek"
ln_arr["gu"]="Gujarati"
ln_arr["ht"]="Haitian Creole"
ln_arr["iw"]="Hebrew"
ln_arr["hi"]="Hindi"
ln_arr["hu"]="Hungarian"
ln_arr["is"]="Icelandic"
ln_arr["id"]="Indonesian"
ln_arr["ga"]="Irish"
ln_arr["it"]="Italian"
ln_arr["ja"]="Japanese"
ln_arr["kn"]="Kannada"
ln_arr["ko"]="Korean"
ln_arr["lo"]="Laothian"
ln_arr["la"]="Latin"
ln_arr["lv"]="Latvian"
ln_arr["lt"]="Lithuanian"
ln_arr["mk"]="Macedonian"
ln_arr["ms"]="Malay"
ln_arr["mt"]="Maltese"
ln_arr["no"]="Norwegian"
ln_arr["fa"]="Persian"
ln_arr["pl"]="Polish"
ln_arr["pt"]="Portuguese"
ln_arr["ro"]="Romanian"
ln_arr["ru"]="Russian"
ln_arr["sr"]="Serbian"
ln_arr["sk"]="Slovak"
ln_arr["sl"]="Slovenian"
ln_arr["es"]="Spanish"
ln_arr["sw"]="Swahili"
ln_arr["sv"]="Swedish"
ln_arr["ta"]="Tamil"
ln_arr["te"]="Telugu"
ln_arr["th"]="Thai"
ln_arr["tr"]="Turkish"
ln_arr["uk"]="Ukrainian"
ln_arr["ur"]="Urdu"
ln_arr["vi"]="Vietnamese"
ln_arr["cy"]="Welsh"
ln_arr["yi"]="Yiddish"

trap bashtrap INT
bashtrap()
{
	echo "CTRL+C Detected"
	rm "$cachefile" 2> /dev/null
	exit
}

jsout_dictionary="var googlearr = eval(JSON.stringify(myJSONObject));
var rsum=\"\"; //translated text
if(typeof googlearr[0] !== 'undefined' && googlearr[0] !== null){  //summing sentences
	for (var i = 0; i < googlearr[0].length; i++){
		if(typeof googlearr[0][i][0] !== 'undefined' && googlearr[0][i][0] !== null){
			rsum=rsum+googlearr[0][i][0];
		}
	}
}
print(\"\033[1;32m\"+rsum+\"\033[0m\");
function dictionary(arr){ //dictionary output
	if(typeof arr[1] !== 'undefined' && arr[1] !== null){
		for (var a = 0; a < arr[1].length; a++){
			if(typeof arr[1][a][0] !== 'undefined' && arr[1][a][0] !== null){
				print(\"\033[1;34m\"+arr[1][a][0]+\"\033[0m\");//part of speach
				for (var b = 0; b < arr[1][a][2].length; b++){//words
					num=parseFloat(arr[1][a][2][b][3]); //frequency
					//not working again :( print(arr[1][a][2][b][0]+' '+arr[1][a][2][b][1]+' '+Math.round(num*1000000)/1000000);//word + variant of speach + frequency
					print(arr[1][a][2][b][0]+' '+arr[1][a][2][b][1]);//word + variant of speach
				}
			}
		}
	}
}
function language_identification(arr){ //dictionary output
	if(typeof arr[8] !== 'undefined' && arr[8] !== null && typeof arr[8][0] !== 'undefined' && arr[8][0] !== null && typeof arr[8][0][0] !== 'undefined' && arr[8][0][0] !== null){
		print('Detected language: '+arr[8][0][0]); //detected language
	}
}
"
comment="arr=googlearr;
for (var c = 0; c < arr.length; c++){ //testing
	if(typeof arr[c] !== 'undefined' && arr[c] !== null){ //dictionary output
		for (var i = 0; i < arr[c].length; i++){
			if(typeof arr[c][i] !== 'undefined' && arr[c][i] !== null){
				for (var e = 0; e < arr[c][i].length; e++){
					print(c);
					print(arr[c][i][e]);
					//print(arr[8][0][1]);
				}
			}
		}
	}
}
	TOO COMPLEX... it was bad idea	whitespace=' ' //for x.x and xxx format
					num2=Math.round(num*10000)/10;
					if (num2 < 10 && num2%1 == 0){
						whitespace='   '; //for x format
					}
					if (num2 >= 10){
						num2=Math.round(num2/10)*10;
						if (num2 < 100){
							whitespace='  '; //for xx format
						}
					}
					print(num2+whitespace+arr[1][a][2][b][0]+' '+arr[1][a][2][b][1]);//frequency + word + variant of speach
"


request=($*) #get array
sound=0
volume=0.7
if [[ $1 = -h || $1 = --help ]]; then #help
	echo "$help"
	exit
fi
if [[ $1 == -s || $1 == -s2 || $1 == -s3 || $1 == --sound ]];then #sound varibles
	sound=1
	[[ $1 == -s2 ]] && volume=1.5
	[[ $1 == -s3 ]] && volume=2.5
	request[0]="" #remove first parameter
fi
request=${request[*]} #to string
[[ ${#request} -eq 0 ]] && exit

source=auto
tchar=${request:0:1} #language detection by the first character
tcharnum=$(printf "%d" "'${tchar}")
if [[ $tcharnum -ge 65 && $tcharnum -le 122 ]]; then #if request is A-Za-z then it is english...
	source=en #english
	target="$ENGLISH_TARGET_LANG" #if text is english, target language is ENGLISH_TARGET_LANG
fi

[[ $TLSOURCE ]] && source=$TLSOURCE; 
[[ $TLTARGET ]] && target=$TLTARGET; # export TLSOURCE=en TLTARGET=ru; will set language

[ ! -d "$PR_DIR" ] && mkdir "$PR_DIR"
[ ! -d "$PR_DIR"/cache ] && mkdir "$PR_DIR"/cache

if [[ ${#request} -gt 300 ]]; then
	if ! result=$(curl -s -i --user-agent "$useragent" $httpsproxy -x "$httpproxy" -d "sl=$source" -d "tl=$target" --data-urlencode "text=$request" http://translate.google.com) && [[ $httpproxy != "" ]] #getting google respond for short sentence
	then	# second attempt without https proxy
		httpsproxy=""
		result=$(curl -s -i --user-agent "$useragent" $httpsproxy -x "$httpproxy" -d "sl=$source" -d "tl=$target" --data-urlencode "text=$request" http://translate.google.com)
	fi
	encoding=$(awk '/Content-Type: .* charset=/ {sub(/^.*charset=["'\'']?/,""); sub(/[ "'\''].*$/,""); print}' <<<"$result")
	#iconv -f $encoding <<<"$result" | awk 'BEGIN {RS="<div"};/<span[^>]* id=["'\'']?result_box["'\'']?/ {sub(/^.*id=["'\'']?result_box["'\'']?(>| [^>]*>)([ \n\t]*<[^>]*>)*/,"");sub(/<.*$/,"");print}' | html2text -utf8
	echo -e "\033[32;1m"$(iconv -f $encoding <<<"$result" |  awk 'BEGIN {RS="</div>"};/<span[^>]* id=["'\'']?result_box["'\'']?/' | html2text -utf8)"\033[0m"

else
	cachefile="$PR_DIR/cache/$source"_"$request" #may be source=auto I will check it hereafter when I made language detection
	r_words_count=$(echo "$request"  |wc -w)
	if [[ ! -e "$cachefile" || (( $sound == 1 && ! -e "$cachefile".mp3 )) ]]; then

		[[ $r_words_count -le 4 ]] && { httpproxy="" ; httpsproxy="" ; } #don't wanna proxy for 4 words.

		if ! grespond=$(curl -s -i --user-agent "$useragent" $httpsproxy -x "$httpproxy" -m $timeout --data-urlencode "text=$request" "http://translate.google.com/translate_a/t?client=t&hl=$target&sl=$source&tl=$target&ie=UTF-8&oe=UTF-8&multires=1&ssel=0&tsel=0&sc=1") && [[ "$httpproxy" != "" ]] #getting google respond for short sentence
		then	# second attempt without https proxy
			#echo https proxy not working. using http proxy.
			httpsproxy=""
			grespond=$(curl -s -i --user-agent "$useragent" $httpsproxy -x "$httpproxy" -m $timeout --data-urlencode "text=$request" "http://translate.google.com/translate_a/t?client=t&hl=$target&sl=$source&tl=$target&ie=UTF-8&oe=UTF-8&multires=1&ssel=0&tsel=0&sc=1") #getting google respond for short sentence
		fi
		[[ ! $(echo $grespond | grep -o '\[.*\]') ]] && { echo "can't connect" ; exit; } #small connection check

		#echo -n "var myJSONObject = " > "$PR_DIR"/tmpjsobj2
		#echo [$(echo "$grespond" | grep -o '"[^"]*/i[^"]*"')"];" >> "$PR_DIR"/tmpjsobj2
		#echo [$(echo "$grespond" | grep -o '[^"]*/i[^"]*')"];"
		#echo -e "var googlearr = eval(JSON.stringify(myJSONObject));\n print(googlearr);" >> "$PR_DIR"/tmpjsobj2
		#js "$PR_DIR"/tmpjsobj2
		fl_raw=$(echo "$grespond" | grep -o '[^"]*/i[^"]*') #google correction from $grespond
		if [[ $r_words_count -le 2 ]];then #getting google fixed text
			fl=$(echo "$fl_raw" | sed 's/\\u003cb\\u003e\\u003ci\\u003e//g' | sed 's/\\u003c\/i\\u003e\\u003c\/b\\u003e//g' | sed 's/\\u0026//g' | sed "s/\#39;/'/g")
			difftest="$(cmp -l <(echo -n $request) <(echo -n $fl) 2>/dev/null)"
			diffnum=$(echo "$difftest" | head -n 1 | sed 's/\([0-9][0-9]\?\).*/\1/') 
			if [[ $diffnum > 0 ]];then
				[[ $source != en ]]&& diffnum=$(($diffnum/2+$diffnum%2))   #MUST BE CHECKED FOR REQUIRED LANGUAGES
				[[ ${fl:$diffnum-1:1} == ' ' ]] && let diffnum-- #white space correction
				fl="$(tput bold)$(tput setaf 3)${fl:0:$diffnum-1}$(tput bold)$(tput setaf 1)${fl:$diffnum-1:1}$(tput bold)$(tput setaf 3)${fl:$diffnum}$(tput sgr0) :$(tput setaf 3)"$(echo "$difftest" | wc -l)"$(tput sgr0)" #highlight difference in one word
			fi
		else
			fl=$(echo "$fl_raw" | sed 's/\\u003cb\\u003e\\u003ci\\u003e/'$(tput bold)$(tput setaf 3)'/g' | sed 's/\\u003c\/i\\u003e\\u003c\/b\\u003e/'$(tput sgr0)'/g' | sed 's/\\u0026//g' | sed "s/\#39;/'/g" ) #google fixed text
		fi

		#echo $grespond | grep -o '\[.*\]'

		echo -n "var myJSONObject = " > "$PR_DIR"/tmpjsobj
		echo -n "$grespond" | grep -o '\[.*\]' >> "$PR_DIR"/tmpjsobj
		echo ";">> "$PR_DIR"/tmpjsobj
		echo -n "$jsout_dictionary" >> "$PR_DIR"/tmpjsobj

		#Language detection
		cp -f "$PR_DIR"/tmpjsobj "$PR_DIR"/tmpjsobj2
		echo -n "language_identification(googlearr);" >> "$PR_DIR"/tmpjsobj2
		det_language=$(js "$PR_DIR"/tmpjsobj2 | tail -c3)
		[[ $det_language != $source && $det_language != $ENGLISH_TARGET_LANG ]] && echo -e "$(tput bold)$(tput setaf 3)$det_language ${ln_arr[$det_language]}$(tput sgr0) detected"

		if [[ $source != "auto" && $source != $det_language && ! $fl_raw ]]; then #second attempt to translate with detected language
			echo -e trying again
			export TLSOURCE=$det_language #TLTARGET=en #source and target language for second attempt
			if [[ $sound == 1 ]]; then $0 -s $request ; else $0 $request ;fi #second attemt to translate with detected language  #sound will be quiet...
			exit
		fi
		
		echo -n "dictionary(googlearr);" >> "$PR_DIR"/tmpjsobj

		[[ $source == "auto" ]] && { source=$det_language; cachefile="$PR_DIR/cache/$source_$request"; } #auto in cachefile fix
	
		#"Dictionary part" for english only. but it can be extended for every required language
		#res_for_check=$(echo "$grespond" | grep -o '\[.*\]' | sed 's/.*\[\[\[\"\([^\"]*\)".*/\1/')
		if [[ $r_words_count -eq 1 && ${#request} -gt 1 && $source == en && ! $fl_raw ]]; then #dictionary

			js "$PR_DIR"/tmpjsobj > "$cachefile" #google translated text and dictionary to cache

			#phrases
			raw_phras=$(curl -s --user-agent "$useragent" $httpsproxy -x "$httpproxy" -m $timeout http://www.macmillandictionary.com/dictionary/american/"$(echo $request | tr ' ' - )" | grep -o '<li ID.*End of DIV SENSE--></li>' | sed 's/<.\?span[^>]*>//g' )
			phras=$(echo $raw_phras |  sed 's/End of DIV SENSE--><\/li>/End of DIV SENSE--><\/li>\n/g' | grep -n -o '"h2">[^>]*<' | sed 's/^\([^:]*\):.*>\([^<]*\).*/\1 \2\./') #getting phrases
			phras2=$(echo $raw_phras |  sed 's/End of DIV SENSE--><\/li>/End of DIV SENSE--><\/li>\n/g' | grep -n -o '"EXAMPLE">[^>]*<' | sed 's/^\([^:]*\):.*>\([^<]*\).*/\1 \2/') #getting examples
			if [[ $phras ]]; then
				echo -e "\033[1;35m"PHRASES:$(tput sgr0) >> "$cachefile"
				join --nocheck-order -a 1 -a 2 <(echo "$phras") <(echo "$phras2")  | sed '/^$/d' >> "$cachefile"
				#echo -e "\033[34m"http://www.macmillandictionary.com/dictionary/american/"$request"$(tput sgr0) >> "$cachefile"
			fi

			trans=$(curl -s --user-agent "$useragent" $httpsproxy -x "$httpproxy" http://lingvopro.abbyyonline.com/en/Translate/en-"$target"/"$request" | grep -o '"[^"]*Handlers/TranscriptionHandler\.ashx[^"]*"' | sed 's/.*=\(.*\)"/\1/'| echo -n -e $(sed 's/+/ /g; s/%/\\x/g')) #getting transcription
			[[ $trans ]] && echo "[$trans]" >> "$cachefile"

			cat "$cachefile" 2>/dev/null #output
			echo -e "\033[34m"http://oxforddictionaries.com/definition/english/"$request"$(tput sgr0) # just another good english dictionary

			if [[ $trans ]] ; then

				#saving words
				if [[ ${#request} -gt 2 && ! $(grep "$request" "$PR_DIR"/translated_words 2>/dev/null) ]]; then
					#echo -e "$request \t\t\t\t\t\t\t\t\t\t [$trans]" >> "$PR_DIR"/translated_words
					echo -e "$request" >> "$PR_DIR"/translated_words
				fi

				#getting sound from forvo.com
				if [[ $sound == 1 && ! -e "$cachefile".mp3 ]]; then
					curl -s -c "$PR_DIR"/tmpcookie --connect-timeout $timeout -m $timeout --user-agent "$useragent" $httpsproxy -x "$httpproxy" -d "login=$flogin&password=$fpass" http://ru.forvo.com/login/ -o/dev/null
					if [[ -e "$PR_DIR"/tmpcookie ]]; then
						slink=$(curl -s -b $PR_DIR/tmpcookie --connect-timeout $timeout -m $timeout --user-agent "$useragent" $httpsproxy -x "$httpproxy" http://ru.forvo.com/word/"$request"/ | grep -o '[^"]*/download/mp3/'"$request"'/en/[^"]*' |head -n 1 )
						[[ $slink ]] && curl -s -b "$PR_DIR"/tmpcookie --connect-timeout $timeout -m $timeout --user-agent "$useragent" $httpsproxy -x "$httpproxy" http://ru.forvo.com"$slink" > "$cachefile".mp3
						rm "$PR_DIR"/tmpcookie 2>/dev/null
					else
						echo fail to get sound from forvo.com
					fi
				fi
			fi
			[[ $(ls "$PR_DIR"/cache | wc -l) -gt $words_buffer ]] && find "$PR_DIR"/cache -mtime +20 -delete #cache cleaning. remove words older than 20 days.
		else
			
			js "$PR_DIR"/tmpjsobj #google dictionary and translated text output
			[[ $fl ]] && echo $fl #google fixed text output

			if [[ $source == en && ! $fl_raw ]]; then 
				#phrases for 2 words
				if [[ $r_words_count -le 2 ]]; then
					raw_phras=$(curl -s --user-agent "$useragent" $httpsproxy -x "$httpproxy" http://www.macmillandictionary.com/dictionary/american/"$(echo $request | tr ' ' - )" | grep -o '<li.*End of DIV SENSE--></li>' | sed 's/<.\?span[^>]*>//g' )
					phras=$(echo $raw_phras |  sed 's/End of DIV SENSE--><\/li>/End of DIV SENSE--><\/li>\n/g' | grep -n -o '"h2">[^>]*<' | sed 's/^\([^:]*\):.*>\([^<]*\).*/\1 \2\./') #getting phrases
					phras2=$(echo $raw_phras |  sed 's/End of DIV SENSE--><\/li>/End of DIV SENSE--><\/li>\n/g' | grep -n -o '"EXAMPLE">[^>]*<' | sed 's/^\([^:]*\):.*>\([^<]*\).*/\1 \2/') #getting examples
					if [[ $phras2 ]]; then
						echo -e "\033[1;35m"PHRASES:$(tput sgr0)
						join --nocheck-order -a 1 -a 2 <(echo "$phras") <(echo "$phras2") | sed '/^$/d'
					fi
				fi
				#search for ideom for 2-4 words
				if [[ ! $phras2 && $r_words_count -le 4 ]]; then
					raw_ideoms=$(curl -s --user-agent "$useragent" $httpsproxy -x "$httpproxy" http://idioms.thefreedictionary.com/"$(echo $request | tr ' ' + )" | grep -o 'div class="ds-single".*</div><div')
					ideom=$(echo $raw_ideoms | sed 's/<i>//' | sed 's/<\/i>//' | sed 's/.*ds-single\">\([^<]*\)<.*/\1/')
					illustration=$(echo $raw_ideoms | sed 's/.*class=illustration>\([^<]*\)<.*/\1/')
					if [[ $ideom ]]; then
						echo -e "\033[1;35m"Ideom:$(tput sgr0)
						echo $ideom
						echo $illustration
					fi
				fi
			fi

		fi #english dictionary
	else #cache output
		cat "$cachefile" #output
		[[ $source == en ]] && echo -e "\033[34m"http://oxforddictionaries.com/definition/english/"$request"$(tput sgr0)
	fi
	#sound output
	if [[ $sound == 1 && -e "$cachefile".mp3 ]]; then 
		stat=$(playsound --loop 0 --volume "$volume" "$cachefile".mp3 2>&1 | grep -o 'Couldn')
		[[ $stat ]] && rm "$cachefile".mp3
	fi
	[[ $sound == 1 ]] && sleep 1 #to be able Ctrl+C and delete files
fi

exit


#rest languages for interface. not in list of source language
#hl=ak          Akan
#hl=bem         Bemba
#hl=bh          Bihari
#hl=xx-bork     Bork, bork, bork!
#hl=bs          Bosnian
#hl=br          Breton
#hl=km          Cambodian
#hl=chr         Cherokee
#hl=ny          Chichewa
#hl=zh-TW       Chinese (Traditional)
#hl=co          Corsican
#hl=xx-elmer    Elmer Fudd
#hl=ee          Ewe
#hl=fy          Frisian
#hl=gaa         Ga
#hl=gn          Guarani
#hl=xx-hacker   Hacker
#hl=ha          Hausa
#hl=haw         Hawaiian
#hl=ig          Igbo
#hl=ia          Interlingua
#hl=jw          Javanese
#hl=kk          Kazakh
#hl=rw          Kinyarwanda
#hl=rn          Kirundi
#hl=xx-klingon  Klingon
#hl=kg          Kongo
#hl=kri         Krio (Sierra Leone)
#hl=ku          Kurdish
#hl=ckb         Kurdish (Soran√Æ)
#hl=ky          Kyrgyz
#hl=ln          Lingala
#hl=loz         Lozi
#hl=lg          Luganda
#hl=ach         Luo
#hl=mg          Malagasy
#hl=ml          Malayalam
#hl=mi          Maori
#hl=mr          Marathi
#hl=mfe         Mauritian Creole
#hl=mo          Moldavian
#hl=mn          Mongolian
#hl=sr-ME       Montenegrin
#hl=ne          Nepali
#hl=pcm         Nigerian Pidgin
#hl=nso         Northern Sotho
#hl=nn          Norwegian (Nynorsk)
#hl=oc          Occitan
#hl=or          Oriya
#hl=om          Oromo
#hl=ps          Pashto
#hl=xx-pirate   Pirate
#hl=pt-BR       Portuguese (Brazil)
#hl=pt-PT       Portuguese (Portugal)
#hl=pa          Punjabi
#hl=qu          Quechua
#hl=rm          Romansh
#hl=nyn         Runyakitara
#hl=gd          Scots Gaelic
#hl=sh          Serbo-Croatian
#hl=st          Sesotho
#hl=tn          Setswana
#hl=crs         Seychellois Creole
#hl=sn          Shona
#hl=sd          Sindhi
#hl=si          Sinhalese
#hl=so          Somali
#hl=es-419      Spanish (Latin American)
#hl=su          Sundanese
#hl=tg          Tajik
#hl=tt          Tatar
#hl=ti          Tigrinya
#hl=to          Tonga
#hl=lua         Tshiluba
#hl=tum         Tumbuka
#hl=tk          Turkmen
#hl=tw          Twi
#hl=ug          Uighur
#hl=uz          Uzbek
#hl=wo          Wolof
#hl=xh          Xhosa
#hl=yo          Yoruba
#hl=zu          Zulu

